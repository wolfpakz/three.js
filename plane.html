<!doctype html>
<html lang="en">
  <head>
    <title>RTS Playground</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        font-family: Monospace;
        background-color: #f0f0f0;
        margin: 0px;
        overflow: hidden;
      }
    </style>
  </head>

  <body>
  </body>

  <script src="examples/js/Detector.js"></script>
  <script src="examples/js/Stats.js"></script>
  <script src="build/Three.js"></script>

  <script>
    var camera, scene, renderer, container, projector, board, counter = 0
    var selected_ids = []
    var selection = {
      waypoint: null,
      shape: null,
      complete: function() {
        // Purge list of selected mobs
        selected_ids = this.shape.selectedMobs()
        for (var i = 0; i < mobs.length; i++) {
          mobs[i].deselect()

          if (selected_ids.indexOf(mobs[i].id) != -1) {
            mobs[i].select(this.waypoint)
          }
        }
      }, // END complete

      beginSelectionBox: function(pos) {
        if (this.shape) {
          scene.remove(this.shape)
        }
        this.shape = createBox(.1, .1, .1)
        this.shape.start = pos.clone() // Must be a cloned/new vector!
        this.shape.position = this.shape.start.clone()
        scene.add(this.shape)

        this.shape.resizeTo = function(pos) {
          var x = pos.x - this.start.x
          var z = pos.z - this.start.z

          this.scale.x    = Math.max(.1, Math.abs(x)*10)
          this.scale.z    = Math.max(.1, Math.abs(z)*10)
          this.position.x = this.start.x + x/2
          this.position.z = this.start.z + z/2
        } // END shape.resizeTo
        
        this.shape.selectedMobs = function() {
          // get box bounds as a < b; c < d
          if (this.end.x < this.start.x) {
            a = this.end.x
            b = this.start.x
          } else {
            a = this.start.x
            b = this.end.x
          }
          if (this.end.z < this.start.z) {
            c = this.end.z
            d = this.start.z
          } else {
            c = this.start.z
            d = this.end.z
          }
          // walk every mob and see if they are in our box
          var list = []
          for (var i = 0; i < mobs.length; i++) {
            x = mobs[i].position.x
            z = mobs[i].position.z
            if (a < x && x < b && c < z && z < d) {
              list.push(mobs[i].id)
            }
          }
          return list
        } // END shape.selectedMobs

      }, // END beginSelectionBox

      beginSelectionCircle: function(pos) {
        if (selection.shape) {
          scene.remove(selection.shape)
        }
        this.shape = createCircle(.1)
        this.shape.start = pos.clone()
        this.shape.position = this.shape.start.clone()
        scene.add(this.shape)

        this.shape.resizeTo = function(pos) {
          var dist = new THREE.Vector3().sub(pos, this.start)

          this.scale.x    = Math.max(.1, dist.length()*10)
          this.scale.z    = Math.max(.1, dist.length()*10)
        }
        
        this.shape.selectedMobs = function() {
          var dist = new THREE.Vector3().sub (this.end, this.start)

          // walk every mob and see if they are in our circle
          if (dist.length() < .2)
            return selected_ids
          var list = []
          for (var i = 0; i < mobs.length; i++) {
            var d = new THREE.Vector3().sub(mobs[i].position, this.start)
            if (d.length() < dist.length()) {
              // then mob is selected!
              list.push(mobs[i].id)
            }
          }
          return list
        }
      }, // END beginSelectionCircle

      reset: function() {
        if (this.waypoint) {
          scene.remove(this.waypoint) // FIXME this is code reuse
          this.waypoint = null
        }
        scene.remove(this.shape)
        this.shape = null
      } // END reset
    }
    var mobs = []

    if (!Detector.webgl) Detector.addGetWebGLMessage()

    init()
    animate()

    function init() {
      container = document.createElement( 'div' )
      document.body.appendChild( container )

      // Create a camera and position it
      camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 )
      camera.position.set( 0, 120, 150 )

      // We eventually do camera.lookAt, so we don't need a target
      //camera.target = new THREE.Vector3( 0, 150, 0 );

      // Create the scene, and add our camera to it
      scene = new THREE.Scene()
      scene.add(camera)

      // Put the land down
      addBoard()

      // Create ambient point light
      addDefaultLight()

      // Create projector to help decide where click landed on the land
      projector = new THREE.Projector()

      // Create a WebGL renderer to render our objects with
      renderer = new THREE.WebGLRenderer()

      // Start the renderer, FIXME: resizable window, plz
      renderer.setSize(window.innerWidth, window.innerHeight)
      container.appendChild(renderer.domElement)

      // Listen for clicks
      document.addEventListener('mousedown', onMouseDown, false)
      document.addEventListener('mousemove', onMouseMove, false)
      document.addEventListener('mouseup',   onMouseUp,   false)
      document.addEventListener('contextmenu', onRightClick, false)
      
    } // END init

    function rightClick(event) {
      var right_click;
      if (!e) var e = window.event;
      if (e.which) right_click = (e.which == 3);
      else if (e.button) right_click = (e.button == 2);
      return right_click
    } // END rightClick
    
    function onMouseDown(event) {
      event.preventDefault()
      var click_point = translateClick(event.clientX, event.clientY)
      if (!click_point) {
        return false
      }
      var team = event.altKey ? 0x333399 : 0x993333
      if (!rightClick(event)) {
        if (event.shiftKey) {
          // Shift-click to add a new mob
          addMob(click_point, team)
        } else {
          selection.reset()
          selection.beginSelectionBox(click_point)
        }
      } else {
        selection.beginSelectionCircle(click_point)
        if (rightClick(event)) {
          selection.waypoint = createWaypoint(selection.shape.start, team)
        }
      }
    } // END onDocumentMouseDown

    function onMouseUp(event) {
      event.preventDefault();

      if (selection.shape) {
        selection.shape.end = translateClick(event.clientX, event.clientY)
        selection.complete()
        selection.reset()
      }

    } // END onDocumentMouseUp
    
    function onMouseMove(event) {
      event.preventDefault()
      
      if (selection.shape) {
        var pt = translateClick(event.clientX, event.clientY)
        if (pt)
          selection.shape.resizeTo(pt)
      }
    } // END onDocumentMouseMove
    
    function onRightClick(event) {
      event.preventDefault();
      return false
    } // END onRightClick
    
    function translateClick(clientX, clientY) {
      var vector = new THREE.Vector3(( clientX / window.innerWidth ) * 2 - 1,
                                    -( clientY / window.innerHeight ) * 2 + 1, 0.5)

      projector.unprojectVector(vector, camera)
      var ray        = new THREE.Ray(camera.position, vector.subSelf(camera.position).normalize())
      var intersects = ray.intersectObjects([board])

      if (intersects.length <= 0) {
        return false; // what does false actually 'do' FIXME
      }
      return intersects[0].point.addSelf(new THREE.Vector3(0,1,0)) // What about multiple values?  Planar is safe.
    } // END translateClick

/*
 * ADD
 */
    function addMob(pos, team_input) {
      var mob = createSphere(1, 32, 16)
      mob.team = team_input // Team colors cannot be above x999999 for x666666 to lighten them
      mob.destination = null
      mob.waypoint = null
      mob.destline = null


      mob.select = function(waypoint) {
        // If we're trying to assign a waypoint, check that the teams match
        if (waypoint && waypoint.team != mob.team)
          return

        // Define this mob as selected by setting a logical, and putting in a list.
        this.selected = true
        this.material.color = new THREE.Color(this.team + 0x666666)
        //selected_mobs.push(this)

        // If there is a waypoint associated with this selection, change my destination to it
        if (waypoint) {
          this.destination = waypoint.position.clone()
        }
        // I'm selected, so show my destination
        if (this.destination) {
          this.waypoint = createWaypoint (this.destination, this.team)
          this.destline = createLine (this.position, this.destination, this.team)
        }
      } // END select


      mob.deselect = function() {
        this.selected = false
        this.material.color = new THREE.Color(mob.team) // No need to keep creating colors FIXME

        // Remove my waypoint & line from the scene
        if (this.waypoint) {
          scene.remove(this.waypoint)
          this.waypoint = null
        }
        if (this.destline) {
          scene.remove(this.destline)
          this.destline = null
        }
      } // END deselect

      // Put the mob as position, pull it out of the plane, set default color
      mob.position = pos
      mob.position.y = 1
      mob.deselect()

      // Add mobs to the global list, increment counter, add it to the scene
      mobs.push(mob)
      counter += 1
      mob.id = counter
      scene.add(mob)
      return mob
    } // END addMob

    function addBoard() {
      // create the board's material
      var texture = THREE.ImageUtils.loadTexture('grass-and-ground-seamless.jpg')
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      texture.repeat.x = 4;
      texture.repeat.y = 4;
      var material = new THREE.MeshLambertMaterial({
        map:texture
      });

      // create the board
      var boardWidth = 512, boardDepth = 512
      var geometry   = new THREE.PlaneGeometry(boardWidth, boardDepth, 10, 10)
      board          = new THREE.Mesh(geometry, material)

      scene.add(board);
    } // END addBoard

    function addDefaultLight() {
      // create a point light
      var pointLight = new THREE.PointLight(0xFFFFFF, 1.0);

      // set its position
      pointLight.position.x = 0;
      pointLight.position.y = 500;
      pointLight.position.z = 0;

      // add to the scene
      scene.add(pointLight);
    } // END addDefaultLight
    
// create Funcs
    function createSphere(radius, segments, rings) {
      // create the sphere's material
      var sphereMaterial =
        new THREE.MeshLambertMaterial({})

      // create a new mesh with sphere geometry
      return new THREE.Mesh(

        new THREE.SphereGeometry(
          radius,
          segments,
          rings),

        sphereMaterial);
    } // END createSphere

    function createBox(w,h,d) {
      // create the sphere's material
      var boxMaterial =
        new THREE.MeshLambertMaterial({
          color:0xAAAAAA,
          opacity: 0.6
        });

      // create a new mesh with box geometry
      return new THREE.Mesh(
        new THREE.CubeGeometry(w,h,d), boxMaterial
      )
    } // END createBox

    function createCircle(r) {
      // create the sphere's material
      var circleMaterial =
        new THREE.MeshLambertMaterial({
          color:0x999933,
          opacity: 0.6
        });

      // create a new mesh with cylinder geometry
      return new THREE.Mesh(
        new THREE.CylinderGeometry(r, r, .1, 32), circleMaterial
      )
    } // END createCircle

    function createWaypoint (pos, team_input) {
      // Make a translucent dome with the team's color
      var waypoint = createSphere(3, 32, 16)
      waypoint.team = team_input
      waypoint.material.color = new THREE.Color( waypoint.team )
      waypoint.material.opacity = 0.7
      waypoint.position = pos.clone()
      scene.add(waypoint)

      return waypoint
    } // END createWaypoint

    function createLine (from, to, team_input) { // FIXME, not showing.
      // Make a translucent line with the team's color
      var material = new THREE.LineBasicMaterial({ color:0xFF0000})
//      material.color = new THREE.Color( team_input )
      var geometry = new THREE.Geometry()
      geometry.vertices.push(new THREE.Vector3(from))
      geometry.vertices.push(new THREE.Vector3(to))
//      geometry.vertices.push(new THREE.Vector3(0,0,0))

      var line = new THREE.Line(geometry, material)
      scene.add(line)

      return line
    } // END createLine


// Funcs
    function animate() {
      // put this function in Animation queue (as defined by Chrome?) for next time step
      requestAnimationFrame(animate);

      // move mobs
      for (var i = 0; i < mobs.length; i++) {
        if (mobs[i].destination) {
          mobs[i].translate(.05, new THREE.Vector3().sub( mobs[i].destination, mobs[i].position ).normalize() )
        }
      }
      // this is the guts of animate, call our render function.
      render()
    } // END animate

    function render() {
      camera.lookAt(scene.position)
      renderer.render(scene, camera)
    } // END render


  </script>
</html>
